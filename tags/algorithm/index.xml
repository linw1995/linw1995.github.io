<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on linw1995</title>
    <link>https://linw1995.com/tags/algorithm/</link>
    <description>Recent content in Algorithm on linw1995</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 24 Oct 2017 08:52:58 +0000</lastBuildDate>
    
	<atom:link href="https://linw1995.com/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>自己来写压缩算法——LZW</title>
      <link>https://linw1995.com/blog/%E8%87%AA%E5%B7%B1%E6%9D%A5%E5%86%99%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95LZW/</link>
      <pubDate>Tue, 24 Oct 2017 08:52:58 +0000</pubDate>
      
      <guid>https://linw1995.com/blog/%E8%87%AA%E5%B7%B1%E6%9D%A5%E5%86%99%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95LZW/</guid>
      <description>之前用哈夫曼算法，把固定长的字符编码根据其出现次数，编码为不固定长的编码。而这次介绍的算法恰恰相反，该算法是把不等长的字符串，编码为固定长的编码。
LZW 蓝博-立夫-卫曲编码法（Lempel-Ziv-Welch，缩写LZW），是亚伯拉罕·蓝波、杰可布·立夫与泰瑞·卫曲共同提出的一种无损数据压缩演算法。与霍夫曼编码相比，LZW把不同长度的字符串转换为固定长的编码。该方法不需要事先对数据做任何分析，所以可以流式地对文件进行处理。
原理 编码 首先先将单字符建立成一个字符串编码表，分别给予编号。
| string | code | |--------|------| | a | 1 | | b | 2 | | c | 3 |  若数据为aabcaac，进过LZW编码后结果为112343，过程如下
| No. | cur | prefix | prefix in str-&amp;gt;code | code | str-&amp;gt;code | |-----|-----|--------|---------------------|------|-----------| | 1 | a | | | | | | 2 | a | a | 1 | | | | 3 | b | aa | 0 | 1 | aa -&amp;gt; 4 | | 4 | c | ab | 0 | 1 | ab -&amp;gt; 5 | | 5 | a | bc | 0 | 2 | bc -&amp;gt; 6 | | 6 | a | ca | 0 | 3 | ca -&amp;gt; 7 | | 7 | c | aa | 1 | | | | 8 | | aac | 0 | 4 | aac -&amp;gt; 8 | | 9 | | c | 1 | 3 | |  整个算法过程如下：</description>
    </item>
    
    <item>
      <title>自己来写压缩算法——哈夫曼算法</title>
      <link>https://linw1995.com/blog/%E8%87%AA%E5%B7%B1%E6%9D%A5%E5%86%99%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 24 Sep 2017 22:24:08 +0000</pubDate>
      
      <guid>https://linw1995.com/blog/%E8%87%AA%E5%B7%B1%E6%9D%A5%E5%86%99%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95/</guid>
      <description>一般文件的编码都是等长的，一些常用字符的编码与很少用到的等长，可若是编码是变长的呢？无疑可以使整个文件大小减小。为了解码时不遇到任何歧义的问题，则每个有效字符所代表的变长编码不能是其它字符的前缀，这种编码也叫做前缀编码。而如何做到这一点呢，接下的内容会尽可能地讲明白。
哈夫曼算法 若是把等长的编码(一字节)用平衡二叉树来表示，字符共有256个，那么树的深度就有 $\log_{2}{256}=8$ 。
如果变作变长编码，那么所有有儿子（child）的节点（node）都不能用来表示，唯有子叶（leaf，没有儿子的节点）才可以用来表示。这是因为每个有效字符所代表的变长编码不能是其它字符的前缀。而且树结构也不可能是平衡二叉树了，树的深度肯定会大于8。
例如，有一份MIT-LICENCE.txt文件，其中空格&#39;&amp;nbsp;&#39;有163个，而字母&#39;v&#39;却只有一个。那么让&#39;&amp;nbsp;&#39;表示为110,&#39;v&#39;表示为0111011101，那么得省$(8 - 3) \times 163 - (8 - 10) \times 1 = 817$个bit。可见变长编码确确实实能起到压缩的作用。
哈夫曼树 哈夫曼树Huffman Tree，也叫做最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为$0$层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为$\operatorname{WPL}=(W_1 \times L_ 1+W_2 \times L_2+W_3 \times L_3+&amp;hellip;+W_n \times L_n)$，$N$个权值$W_i(i=1,2,&amp;hellip;n)$构成一棵有$N$个叶结点的二叉树，相应的叶结点的路径长度为$L_i(i=1,2,&amp;hellip;n)$。可以证明霍夫曼树的$\operatorname{WPL}$是最小的。
/-40 /-40 /-40 /-| /-| /-| | \-48 | \-48 | | /-48 --| | | \-| | /-60 --| /-60 --| \-18 \-| | /-| | | /-30 | | \-20 | /-60 \-| \-| | /-| | /-18 | /-30 \-| \-20 \-| \-| | \-20 \-18 \-30 (0) (1) (2)  计算上面三颗树的$\operatorname{WPL}$：</description>
    </item>
    
    <item>
      <title>伪随机数</title>
      <link>https://linw1995.com/blog/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Fri, 05 May 2017 22:42:12 +0000</pubDate>
      
      <guid>https://linw1995.com/blog/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>序  伪随机性（英语：Pseudorandomness）是指一个过程似乎是随机的，但实际上并不是。例如伪随机数（或称伪乱数），是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。在计算伪随机数时假如使用的开始值不变的话，那么伪随机数的数序也不变。伪随机数的随机性可以用它的统计特性来衡量，其主要特征是每个数出现的可能性和它出现时与数序中其它数的关系。伪随机数的优点是它的计算比较简单，而且只使用少数数值很难推算出计算它的算法。一般人们使用一个假的随机数，比如电脑上的时间作为计算伪随机数的开始值。
 产生随机数的方法  线性同余法 平方取中法 M-Sequence 梅森旋转算法 伪随机数二进制数列  其中使用最多的是线性同余法和梅森旋转算法，下面主要介绍一下线性同余法
线性同余法（LCG linear congruential generator） 线性同余方法（LCG）是个产生伪随机数的方法。 它是根据递归公式： $$N_{j+1}\equiv (A\times N_{j}+C){\pmod {M}}$$ 其中$A,C,M$是产生器设定的常数。
Python implementation class Random: def __init__(self, A, C, M, seed=0): self._A = A self._C = C self._M = M self._prev = seed % M def __call__(self): A = self._A C = self._C M = self._M prev = self._prev cur = self._prev = (A * prev + C) % M return cur / M def __repr__(self): return &#39;Random(A={obj.</description>
    </item>
    
    <item>
      <title>AA树的平衡与再平衡</title>
      <link>https://linw1995.com/blog/AA%E6%A0%91%E7%9A%84%E5%B9%B3%E8%A1%A1%E4%B8%8E%E5%86%8D%E5%B9%B3%E8%A1%A1/</link>
      <pubDate>Thu, 27 Apr 2017 12:38:13 +0000</pubDate>
      
      <guid>https://linw1995.com/blog/AA%E6%A0%91%E7%9A%84%E5%B9%B3%E8%A1%A1%E4%B8%8E%E5%86%8D%E5%B9%B3%E8%A1%A1/</guid>
      <description>介绍  AA树在计算机科学一种形式的自平衡二叉查找树用于高效存储和检索序数据。AA树的名称是由它的发明者*Arne Andersson*而来。 AA树是红黑树的一种变种，是*Arne Andersson教授在1993年年在他的论文&amp;ldquo;Balanced search trees made simple&amp;rdquo;*中介绍，设计的目的是减少红黑树考虑的不同情况，区别于红黑树的是，AA树的红节点只能作为右叶子。换句话说，没有红节点可以是一个左子儿。这导致代替2-3-4树，从而大大简化了维护2-3树的模拟。维护红黑树的平衡需要考虑7种不同的情况:
  因为AA树有严格的条件(红节点只能为右节点)，故只需考虑2种情形:
 AA树是2-3树的模拟，2-3树和AA树是等距同构的。其节点类型如下
平衡条件 树是用与高效的存储和检索数据的，为了维持其效率，必须维持其平衡结构。 平衡一颗红黑树需记录其颜色，而AA树是在每个节点记录其level这相当于红黑树节点的黑高度
 所有叶节点的level都是1 每个左孩子的level恰好为其父亲的level减一 每个右孩子的level等于其父亲的level或为其父亲的level减一 每个右孙子的level严格小于其祖父节点的level 每一个level大于1的节点有两个子节点  Skew &amp;amp; Split 对于AA树，维持其平衡的基本操作如下：
 偏斜Skew：使得子树中向左的水平边变成向右的。
不满足平衡条件：2
def skew(node): if node is None or node.left is None: return node if node.left.level != node.level: return node lft = node.left node.left = lft.right # B =&amp;gt; C change to D =&amp;gt; C lft.right = node # D =&amp;gt; B change to B =&amp;gt; D return lft # top =&amp;gt; D change to top =&amp;gt; B   判断是否是偏斜 i.</description>
    </item>
    
  </channel>
</rss>